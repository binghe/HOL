structure Systeml :> Systeml = struct

(* This is the WINDOWS implementation of the Systeml functionality.
   It is the very first thing compiled by the HOL build process so it
   absolutely can not depend on any other HOL source code. *)

structure Path =  OS.Path
structure Process = OS.Process
structure FileSys = OS.FileSys

local
  open Process

  fun dquote s = concat ["\"", s, "\""]

  fun concat_wspaces munge acc strl =
    case strl of
      [] => concat (List.rev acc)
    | [x] => concat (List.rev (munge x :: acc))
    | (x::xs) => concat_wspaces munge (" " :: munge x :: acc) xs
in

fun systeml l = let
  val command = "call "^concat_wspaces dquote [] l
in
  Process.system command
end

  fun get_first f [] = NONE
    | get_first f (h::t) = case f h of NONE => get_first f t
                                     | x => x


  fun find_my_path () = let
    (* assumes directory hasn't been changed yet *)
    val myname = CommandLine.name()
    val {dir,file} = Path.splitDirFile myname
  in
    if dir = "" then let
        val pathdirs = String.tokens (fn c => c = #":")
                                     (valOf (Process.getEnv "PATH"))
        open FileSys
        fun checkdir d = let
          val f = Path.concat(d,file)
        in
          if access(f, [A_READ, A_EXEC]) then SOME f else NONE
        end
      in
        valOf (get_first checkdir pathdirs)
      end
    else
      Path.mkAbsolute {path = myname, relativeTo = FileSys.getDir()}
  end

val protect = dquote

(* the _ps suffix stands for 'protected string', as opposed to the 'l'
   of systeml, which stands for 'list' of strings (all of which are
   presumed unprotected).  The problem is that on Windows, if you pass
   system a (protected) string such as
      "c:/program files/bar/baz" "arg1"
   then it has a fit.  It seems the only way of getting it to play nicely
   is to prefix the commandline with "call". *)
fun system_ps s = Process.system ("call " ^ s)

fun xable_string s = s^".exe"

fun mk_xable file =   (* returns the name of the executable *)
    let val exe = file^".exe"
        val _ = FileSys.remove exe handle _ => ()
    in
      FileSys.rename{old=file, new=exe};
      OS.Process.success
    end


fun normPath s = Path.toString(Path.fromString s)

fun fullPath slist =
    normPath (List.foldl (fn (p1,p2) => Path.concat(p2,p1))
                         (hd slist) (tl slist))


(* these values are filled in by configure.sml *)
val HOLDIR = ""
val MOSMLDIR = ""
val HAVE_BASIS2002 = false
val POLYMLLIBDIR = ""
val POLY = ""
val POLYC = ""
val POLY_VERSION = PolyML.Compiler.compilerVersionNumber
val POLY_LDFLAGS = []
val POLY_LDFLAGS_STATIC = []
val CC = ""
val OS = ""

val DEPDIR = ""
val GNUMAKE = ""
val DYNLIB = ""
val version = ""
val ML_SYSNAME = ""
val release = ""
val DOT_PATH = ""
val DEFAULT_STATE = fullPath [HOLDIR, "bin", "hol.state"]

val isUnix = false

val pointer_eq = PolyML.pointerEq

fun exec (x as (comm,args)) =
    OS.Process.exit (systeml (comm::tl args))

val build_log_dir = fullPath [HOLDIR, "tools-poly", "build-logs"]
val build_log_file = fullPath [build_log_dir, "current-build-log"]
val make_log_file = "current-make-log";
val build_after_reloc_envvar = "HOL_REBUILD_HEAPS_ONLY"

fun base_interactive state scripts =
    [POLY, "-q", "--use", fullPath [HOLDIR, "bin", "hol.ML"], state] @ scripts


  fun emit_hol_script target exe s =
      let val ostrm = TextIO.openOut target
          fun output s = TextIO.output(ostrm, s)
          val script =
            List.map (fn s => protect (fullPath [HOLDIR, "tools-poly", s]))
                     s
      in
        output "@echo off\n";
        output "rem The bare HOL script\n";
        output "rem (automatically generated by HOL configuration)\n\n";
        output (String.concatWith " " (base_interactive exe script) ^ "\n");
        TextIO.closeOut ostrm;
        mk_xable target
      end;

  fun emit_hol_unquote_script target exe s =
      let val ostrm = TextIO.openOut (target^".bat")
          fun output s = TextIO.output(ostrm, s)
          val qfilter = protect (fullPath [HOLDIR, "bin", "unquote"])
          val script =
            List.map (fn s => protect (fullPath [HOLDIR, "tools-poly", s]))
                     s
      in
        output "@echo off\n";
        output "rem The HOL script (with quote preprocessing)\n";
        output "rem (automatically generated by HOL configuration)\n\n";
        output (String.concatWith " "
                   ([qfilter, "|"] @ base_interactive exe script) ^ "\n");
        TextIO.closeOut ostrm;
        mk_xable target
      end;
end (* local *)

end; (* struct *)
